#!/bin/bash

# Script de configuraciÃ³n para Sistema de Cobro de Agua Potable (PostgreSQL)
# Ejecutar desde la raÃ­z del proyecto

echo "ðŸš€ Iniciando configuraciÃ³n del proyecto..."

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ============================================
# BACKEND
# ============================================

echo -e "${GREEN}ðŸ“¦ Configurando Backend...${NC}"

# Crear carpetas faltantes en backend
mkdir -p backend/services
mkdir -p backend/tests/unit
mkdir -p backend/tests/integration

# .env.example para backend (PostgreSQL)
cat > backend/.env.example << 'EOF'
# Server Configuration
PORT=3000
NODE_ENV=development

# PostgreSQL Database Configuration
DB_HOST=localhost
DB_USER=postgres
DB_PASSWORD=tu_password
DB_NAME=agua_potable
DB_PORT=5432

# JWT Configuration
JWT_SECRET=tu_clave_secreta_super_segura_cambiar_en_produccion
JWT_EXPIRES_IN=24h

# CORS Configuration
CORS_ORIGIN=http://localhost:5173

# Email Configuration (opcional)
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USER=
EMAIL_PASSWORD=
EOF

echo -e "${BLUE}âœ“ Creado: backend/.env.example${NC}"

# .gitignore para backend
cat > backend/.gitignore << 'EOF'
# Dependencies
node_modules/
package-lock.json

# Environment variables
.env
.env.local
.env.production

# Logs
logs/
*.log
npm-debug.log*

# OS
.DS_Store
Thumbs.db
.idea/
.vscode/

# Testing
coverage/
.nyc_output/

# Build
dist/
build/
EOF

echo -e "${BLUE}âœ“ Creado: backend/.gitignore${NC}"

# README.md para backend
cat > backend/README.md << 'EOF'
# Backend - Sistema de Cobro de Agua Potable

API REST para gestiÃ³n de cobro de agua potable en comunidades pequeÃ±as (PostgreSQL).

## ðŸš€ InstalaciÃ³n

```bash
npm install
```

## âš™ï¸ ConfiguraciÃ³n

1. Copiar `.env.example` a `.env`
2. Configurar las variables de entorno con tus credenciales PostgreSQL
3. La base de datos ya debe estar creada e inicializada

## ðŸ“¦ Dependencias Necesarias

```bash
npm install express pg dotenv bcryptjs jsonwebtoken cors express-validator morgan
npm install --save-dev nodemon
```

## ðŸƒ EjecuciÃ³n

### Desarrollo
```bash
npm run dev
```

### ProducciÃ³n
```bash
npm start
```

## ðŸ“ Estructura

- `/config` - ConfiguraciÃ³n de base de datos
- `/controllers` - Controladores de rutas
- `/models` - Modelos de base de datos
- `/routes` - DefiniciÃ³n de rutas
- `/middleware` - Middleware personalizado
- `/services` - LÃ³gica de negocio
- `/utils` - Utilidades y helpers

## ðŸ”‘ Variables de Entorno

Ver `.env.example` para la lista completa de variables requeridas.

## ðŸ“ API Endpoints

### AutenticaciÃ³n
- `POST /api/auth/login` - Iniciar sesiÃ³n
- `POST /api/auth/logout` - Cerrar sesiÃ³n

### Usuarios
- `GET /api/users` - Listar usuarios
- `GET /api/users/:id` - Obtener usuario
- `POST /api/users` - Crear usuario
- `PUT /api/users/:id` - Actualizar usuario
- `DELETE /api/users/:id` - Eliminar usuario

### Medidores
- `GET /api/medidores` - Listar medidores
- `POST /api/medidores` - Crear medidor
- `GET /api/medidores/:id` - Obtener medidor

### Mediciones
- `GET /api/mediciones` - Listar mediciones
- `POST /api/mediciones` - Crear mediciÃ³n
- `GET /api/mediciones/:id` - Obtener mediciÃ³n

### Facturas
- `GET /api/facturas` - Listar facturas
- `POST /api/facturas` - Generar factura
- `GET /api/facturas/:id` - Obtener factura
- `PUT /api/facturas/:id/pagar` - Registrar pago

### Reportes
- `GET /api/reportes/consumo` - Reporte de consumo
- `GET /api/reportes/pagos` - Reporte de pagos
- `GET /api/reportes/morosos` - Reporte de morosos
EOF

echo -e "${BLUE}âœ“ Creado: backend/README.md${NC}"

# Actualizar database.js para PostgreSQL
cat > backend/config/database.js << 'EOF'
// ConfiguraciÃ³n de PostgreSQL
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 5432,
  user: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME || 'agua_potable',
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

// Verificar conexiÃ³n
pool.on('connect', () => {
  console.log('âœ“ Conectado a PostgreSQL');
});

pool.on('error', (err) => {
  console.error('Error inesperado en PostgreSQL', err);
  process.exit(-1);
});

module.exports = pool;
EOF

echo -e "${BLUE}âœ“ Actualizado: backend/config/database.js${NC}"

# constants.js
cat > backend/utils/constants.js << 'EOF'
// Constantes del Sistema de Cobro de Agua

// Roles de usuario del sistema
const ROLES = {
  ADMIN: 'admin',
  OPERADOR: 'operador',
  LECTOR: 'lector'
};

// Tipos de usuario del servicio
const TIPOS_USUARIO = {
  DOMESTICO: 'domestico',
  COMERCIAL: 'comercial',
  INDUSTRIAL: 'industrial'
};

// Estados de factura
const ESTADOS_FACTURA = {
  PENDIENTE: 'pendiente',
  PAGADA: 'pagada',
  VENCIDA: 'vencida',
  PARCIAL: 'parcial',
  CANCELADA: 'cancelada'
};

// Estados de usuario/medidor
const ESTADOS = {
  ACTIVO: 'activo',
  SUSPENDIDO: 'suspendido',
  INACTIVO: 'inactivo',
  BLOQUEADO: 'bloqueado'
};

// MÃ©todos de pago
const METODOS_PAGO = {
  EFECTIVO: 'efectivo',
  TRANSFERENCIA: 'transferencia',
  TARJETA: 'tarjeta',
  CHEQUE: 'cheque'
};

// ConfiguraciÃ³n de tarifas por defecto
const TARIFAS_DEFAULT = {
  DOMESTICO: {
    BASE: 50,
    POR_M3: 5,
    MINIMO: 10
  },
  COMERCIAL: {
    BASE: 100,
    POR_M3: 8,
    MINIMO: 15
  },
  INDUSTRIAL: {
    BASE: 200,
    POR_M3: 12,
    MINIMO: 20
  }
};

module.exports = {
  ROLES,
  TIPOS_USUARIO,
  ESTADOS_FACTURA,
  ESTADOS,
  METODOS_PAGO,
  TARIFAS_DEFAULT
};
EOF

echo -e "${BLUE}âœ“ Creado: backend/utils/constants.js${NC}"

# helpers.js
cat > backend/utils/helpers.js << 'EOF'
// Funciones auxiliares

/**
 * Formatea una fecha a string YYYY-MM-DD
 */
const formatDate = (date) => {
  const d = new Date(date);
  return d.toISOString().split('T')[0];
};

/**
 * Obtiene el periodo actual (YYYY-MM)
 */
const getPeriodoActual = () => {
  const fecha = new Date();
  const year = fecha.getFullYear();
  const month = String(fecha.getMonth() + 1).padStart(2, '0');
  return `${year}-${month}`;
};

/**
 * Calcula el consumo entre dos lecturas
 */
const calcularConsumo = (lecturaActual, lecturaAnterior) => {
  const consumo = parseFloat(lecturaActual) - parseFloat(lecturaAnterior);
  return consumo >= 0 ? consumo : 0;
};

/**
 * Calcula el monto segÃºn tarifa y consumo
 */
const calcularMonto = (consumo, tarifa) => {
  const { tarifa_base, tarifa_por_m3, consumo_minimo } = tarifa;
  
  if (consumo <= consumo_minimo) {
    return parseFloat(tarifa_base);
  }
  
  const consumoAdicional = consumo - consumo_minimo;
  return parseFloat(tarifa_base) + (consumoAdicional * parseFloat(tarifa_por_m3));
};

/**
 * Genera un nÃºmero de factura Ãºnico
 */
const generarNumeroFactura = (periodo) => {
  const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
  return `FAC-${periodo.replace('-', '')}-${random}`;
};

/**
 * Valida si una fecha estÃ¡ vencida
 */
const estaVencida = (fechaVencimiento) => {
  const hoy = new Date();
  hoy.setHours(0, 0, 0, 0);
  const vencimiento = new Date(fechaVencimiento);
  vencimiento.setHours(0, 0, 0, 0);
  return vencimiento < hoy;
};

/**
 * Calcula la fecha de vencimiento (30 dÃ­as despuÃ©s de emisiÃ³n)
 */
const calcularFechaVencimiento = (fechaEmision = new Date(), dias = 30) => {
  const fecha = new Date(fechaEmision);
  fecha.setDate(fecha.getDate() + dias);
  return fecha;
};

/**
 * Valida formato de periodo (YYYY-MM)
 */
const validarPeriodo = (periodo) => {
  const regex = /^\d{4}-(0[1-9]|1[0-2])$/;
  return regex.test(periodo);
};

/**
 * Sanitiza input para prevenir SQL injection
 */
const sanitizeInput = (input) => {
  if (typeof input !== 'string') return input;
  return input.trim().replace(/[<>]/g, '');
};

module.exports = {
  formatDate,
  getPeriodoActual,
  calcularConsumo,
  calcularMonto,
  generarNumeroFactura,
  estaVencida,
  calcularFechaVencimiento,
  validarPeriodo,
  sanitizeInput
};
EOF

echo -e "${BLUE}âœ“ Creado: backend/utils/helpers.js${NC}"

# errorHandler.js
cat > backend/middleware/errorHandler.js << 'EOF'
// Middleware de manejo de errores

const errorHandler = (err, req, res, next) => {
  console.error('âŒ Error:', err);

  // Error de validaciÃ³n de express-validator
  if (err.name === 'ValidationError') {
    return res.status(400).json({
      success: false,
      message: 'Error de validaciÃ³n',
      errors: err.errors
    });
  }

  // Error de JWT
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({
      success: false,
      message: 'Token invÃ¡lido'
    });
  }

  if (err.name === 'TokenExpiredError') {
    return res.status(401).json({
      success: false,
      message: 'Token expirado'
    });
  }

  // Error de PostgreSQL - unique constraint
  if (err.code === '23505') {
    return res.status(409).json({
      success: false,
      message: 'El registro ya existe (valor duplicado)'
    });
  }

  // Error de PostgreSQL - foreign key constraint
  if (err.code === '23503') {
    return res.status(400).json({
      success: false,
      message: 'Referencia invÃ¡lida: el registro relacionado no existe'
    });
  }

  // Error de PostgreSQL - not null constraint
  if (err.code === '23502') {
    return res.status(400).json({
      success: false,
      message: 'Campo requerido faltante'
    });
  }

  // Error genÃ©rico
  const statusCode = err.statusCode || 500;
  res.status(statusCode).json({
    success: false,
    message: err.message || 'Error interno del servidor',
    ...(process.env.NODE_ENV === 'development' && { 
      stack: err.stack,
      code: err.code 
    })
  });
};

// Middleware para rutas no encontradas
const notFound = (req, res, next) => {
  const error = new Error(`Ruta no encontrada - ${req.originalUrl}`);
  res.status(404);
  next(error);
};

module.exports = { errorHandler, notFound };
EOF

echo -e "${BLUE}âœ“ Creado: backend/middleware/errorHandler.js${NC}"

# roleMiddleware.js
cat > backend/middleware/roleMiddleware.js << 'EOF'
// Middleware de verificaciÃ³n de roles

const { ROLES } = require('../utils/constants');

/**
 * Middleware para verificar si el usuario tiene un rol especÃ­fico
 */
const checkRole = (...allowedRoles) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: 'No autenticado'
      });
    }

    const userRole = req.user.rol;

    if (!allowedRoles.includes(userRole)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para realizar esta acciÃ³n',
        requiredRoles: allowedRoles,
        yourRole: userRole
      });
    }

    next();
  };
};

/**
 * Middleware para verificar si es admin
 */
const isAdmin = checkRole(ROLES.ADMIN);

/**
 * Middleware para verificar si es admin u operador
 */
const isAdminOrOperador = checkRole(ROLES.ADMIN, ROLES.OPERADOR);

/**
 * Middleware para cualquier usuario autenticado
 */
const isAuthenticated = (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({
      success: false,
      message: 'Debes iniciar sesiÃ³n para acceder a este recurso'
    });
  }
  next();
};

module.exports = {
  checkRole,
  isAdmin,
  isAdminOrOperador,
  isAuthenticated
};
EOF

echo -e "${BLUE}âœ“ Creado: backend/middleware/roleMiddleware.js${NC}"

# Modelo Usuario.js actualizado para PostgreSQL
cat > backend/models/Usuario.js << 'EOF'
// Modelo de Usuario (PostgreSQL)

const db = require('../config/database');

class Usuario {
  
  /**
   * Eliminar factura
   */
  static async eliminar(id) {
    const query = 'DELETE FROM facturas WHERE id = $1';
    await db.query(query, [id]);
  }
}

module.exports = Factura;
EOF

echo -e "${BLUE}âœ“ Creado: backend/models/Factura.js${NC}"

# Modelo Medidor.js para PostgreSQL
cat > backend/models/Medidor.js << 'EOF'
// Modelo de Medidor (PostgreSQL)

const db = require('../config/database');

class Medidor {
  
  /**
   * Crear un nuevo medidor
   */
  static async crear(datos) {
    const { 
      numero_medidor, usuario_id, marca, modelo, 
      fecha_instalacion, lectura_inicial 
    } = datos;
    
    const query = `
      INSERT INTO medidores 
      (numero_medidor, usuario_id, marca, modelo, fecha_instalacion, lectura_inicial, estado)
      VALUES ($1, $2, $3, $4, $5, $6, 'activo')
      RETURNING *
    `;
    
    const values = [numero_medidor, usuario_id, marca, modelo, fecha_instalacion, lectura_inicial || 0];
    const result = await db.query(query, values);
    return result.rows[0];
  }

  /**
   * Obtener todos los medidores con informaciÃ³n del usuario
   */
  static async obtenerTodos(filtros = {}) {
    let query = `
      SELECT m.*, u.numero_usuario, u.nombres, u.apellidos, u.direccion
      FROM medidores m
      LEFT JOIN usuarios u ON m.usuario_id = u.id
      WHERE 1=1
    `;
    
    const values = [];
    let paramCount = 1;

    if (filtros.usuario_id) {
      query += ` AND m.usuario_id = ${paramCount}`;
      values.push(filtros.usuario_id);
      paramCount++;
    }

    if (filtros.estado) {
      query += ` AND m.estado = ${paramCount}`;
      values.push(filtros.estado);
      paramCount++;
    }

    query += ' ORDER BY m.numero_medidor';

    const result = await db.query(query, values);
    return result.rows;
  }

  /**
   * Obtener medidor por ID
   */
  static async obtenerPorId(id) {
    const query = `
      SELECT m.*, u.numero_usuario, u.nombres, u.apellidos, u.direccion
      FROM medidores m
      LEFT JOIN usuarios u ON m.usuario_id = u.id
      WHERE m.id = $1
    `;
    
    const result = await db.query(query, [id]);
    return result.rows[0];
  }

  /**
   * Obtener medidor por nÃºmero
   */
  static async obtenerPorNumero(numero_medidor) {
    const query = 'SELECT * FROM medidores WHERE numero_medidor = $1';
    const result = await db.query(query, [numero_medidor]);
    return result.rows[0];
  }

  /**
   * Actualizar medidor
   */
  static async actualizar(id, datos) {
    const { marca, modelo, estado, usuario_id } = datos;
    
    const query = `
      UPDATE medidores 
      SET marca = $1, modelo = $2, estado = $3, usuario_id = $4
      WHERE id = $5
      RETURNING *
    `;
    
    const values = [marca, modelo, estado, usuario_id, id];
    const result = await db.query(query, values);
    return result.rows[0];
  }

  /**
   * Eliminar medidor
   */
  static async eliminar(id) {
    const query = 'DELETE FROM medidores WHERE id = $1';
    await db.query(query, [id]);
  }
}

module.exports = Medidor;
EOF

echo -e "${BLUE}âœ“ Creado: backend/models/Medidor.js${NC}"

# Modelo index.js
cat > backend/models/index.js << 'EOF'
// Exportar todos los modelos

const Usuario = require('./Usuario');
const Medidor = require('./Medidor');
const Medicion = require('./Medicion');
const Factura = require('./Factura');

module.exports = {
  Usuario,
  Medidor,
  Medicion,
  Factura
};
EOF

echo -e "${BLUE}âœ“ Creado: backend/models/index.js${NC}"

# ============================================
# FRONTEND
# ============================================

echo -e "${GREEN}ðŸŽ¨ Configurando Frontend...${NC}"

# Crear carpetas en frontend
mkdir -p frontend/src/components/layout
mkdir -p frontend/src/components/common
mkdir -p frontend/src/components/usuarios
mkdir -p frontend/src/components/medidores
mkdir -p frontend/src/components/mediciones
mkdir -p frontend/src/components/facturas
mkdir -p frontend/src/components/reportes
mkdir -p frontend/src/pages
mkdir -p frontend/src/context
mkdir -p frontend/src/hooks
mkdir -p frontend/src/services
mkdir -p frontend/src/utils
mkdir -p frontend/src/router

# .env para frontend
cat > frontend/.env << 'EOF'
VITE_API_URL=http://localhost:3000/api
VITE_APP_NAME=Sistema de Cobro de Agua Potable
EOF

echo -e "${BLUE}âœ“ Creado: frontend/.env${NC}"

# .gitignore para frontend
cat > frontend/.gitignore << 'EOF'
# Dependencies
node_modules/

# Environment variables
.env
.env.local
.env.production

# Build
dist/
dist-ssr/
*.local

# Editor
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Testing
coverage/
EOF

echo -e "${BLUE}âœ“ Creado: frontend/.gitignore${NC}"

# constants.js para frontend
cat > frontend/src/utils/constants.js << 'EOF'
// Constantes del Frontend

export const ROLES = {
  ADMIN: 'admin',
  OPERADOR: 'operador',
  LECTOR: 'lector'
};

export const TIPOS_USUARIO = {
  DOMESTICO: 'domestico',
  COMERCIAL: 'comercial',
  INDUSTRIAL: 'industrial'
};

export const ESTADOS_FACTURA = {
  PENDIENTE: 'pendiente',
  PAGADA: 'pagada',
  VENCIDA: 'vencida',
  PARCIAL: 'parcial',
  CANCELADA: 'cancelada'
};

export const ESTADOS = {
  ACTIVO: 'activo',
  SUSPENDIDO: 'suspendido',
  INACTIVO: 'inactivo',
  BLOQUEADO: 'bloqueado'
};

export const METODOS_PAGO = {
  EFECTIVO: 'efectivo',
  TRANSFERENCIA: 'transferencia',
  TARJETA: 'tarjeta',
  CHEQUE: 'cheque'
};

export const RUTAS = {
  LOGIN: '/login',
  DASHBOARD: '/dashboard',
  USUARIOS: '/usuarios',
  MEDIDORES: '/medidores',
  MEDICIONES: '/mediciones',
  FACTURAS: '/facturas',
  REPORTES: '/reportes'
};

export const API_URL = import.meta.env.VITE_API_URL;
export const APP_NAME = import.meta.env.VITE_APP_NAME;
EOF

echo -e "${BLUE}âœ“ Creado: frontend/src/utils/constants.js${NC}"

# formatters.js
cat > frontend/src/utils/formatters.js << 'EOF'
// Funciones de formateo

/**
 * Formatea un nÃºmero como moneda mexicana
 */
export const formatCurrency = (amount) => {
  return new Intl.NumberFormat('es-MX', {
    style: 'currency',
    currency: 'MXN'
  }).format(amount);
};

/**
 * Formatea una fecha larga
 */
export const formatDate = (date) => {
  if (!date) return '';
  return new Date(date).toLocaleDateString('es-MX', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
};

/**
 * Formatea una fecha corta (DD/MM/YYYY)
 */
export const formatShortDate = (date) => {
  if (!date) return '';
  return new Date(date).toLocaleDateString('es-MX');
};

/**
 * Formatea fecha para input type="date" (YYYY-MM-DD)
 */
export const formatDateForInput = (date) => {
  if (!date) return '';
  const d = new Date(date);
  return d.toISOString().split('T')[0];
};

/**
 * Formatea un nÃºmero con decimales
 */
export const formatNumber = (number, decimals = 2) => {
  return Number(number).toFixed(decimals);
};

/**
 * Formatea periodo (YYYY-MM a "Mes AÃ±o")
 */
export const formatPeriodo = (periodo) => {
  if (!periodo) return '';
  const [year, month] = periodo.split('-');
  const fecha = new Date(year, parseInt(month) - 1);
  return fecha.toLocaleDateString('es-MX', { year: 'numeric', month: 'long' });
};

/**
 * Obtiene el color segÃºn el estado de factura
 */
export const getEstadoColor = (estado) => {
  const colores = {
    pendiente: 'bg-yellow-100 text-yellow-800 border-yellow-300',
    pagada: 'bg-green-100 text-green-800 border-green-300',
    vencida: 'bg-red-100 text-red-800 border-red-300',
    parcial: 'bg-blue-100 text-blue-800 border-blue-300',
    cancelada: 'bg-gray-100 text-gray-800 border-gray-300'
  };
  return colores[estado] || 'bg-gray-100 text-gray-800 border-gray-300';
};

/**
 * Obtiene el badge del tipo de usuario
 */
export const getTipoUsuarioColor = (tipo) => {
  const colores = {
    domestico: 'bg-blue-100 text-blue-800',
    comercial: 'bg-purple-100 text-purple-800',
    industrial: 'bg-orange-100 text-orange-800'
  };
  return colores[tipo] || 'bg-gray-100 text-gray-800';
};

/**
 * Capitaliza la primera letra
 */
export const capitalize = (str) => {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
};
EOF

echo -e "${BLUE}âœ“ Creado: frontend/src/utils/formatters.js${NC}"

# validators.js
cat > frontend/src/utils/validators.js << 'EOF'
// Funciones de validaciÃ³n

/**
 * Valida email
 */
export const isValidEmail = (email) => {
  const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return regex.test(email);
};

/**
 * Valida telÃ©fono (10 dÃ­gitos)
 */
export const isValidPhone = (phone) => {
  const regex = /^\d{10}$/;
  return regex.test(phone.replace(/\s|-/g, ''));
};

/**
 * Valida periodo (YYYY-MM)
 */
export const isValidPeriodo = (periodo) => {
  const regex = /^\d{4}-(0[1-9]|1[0-2])$/;
  return regex.test(periodo);
};

/**
 * Valida que un nÃºmero sea positivo
 */
export const isPositiveNumber = (num) => {
  return !isNaN(num) && parseFloat(num) > 0;
};

/**
 * Valida longitud mÃ­nima
 */
export const minLength = (str, min) => {
  return str && str.length >= min;
};

/**
 * Valida que los campos requeridos no estÃ©n vacÃ­os
 */
export const validateRequired = (fields) => {
  const errors = {};
  
  Object.keys(fields).forEach(key => {
    if (!fields[key] || fields[key].toString().trim() === '') {
      errors[key] = 'Este campo es requerido';
    }
  });
  
  return errors;
};
EOF

echo -e "${BLUE}âœ“ Creado: frontend/src/utils/validators.js${NC}"

# api.js
cat > frontend/src/services/api.js << 'EOF'
// ConfiguraciÃ³n de API con Axios

import axios from 'axios';
import { API_URL } from '../utils/constants';

// Crear instancia de axios
const api = axios.create({
  baseURL: API_URL,
  timeout: 15000,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Interceptor para agregar token a todas las peticiones
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Interceptor para manejar errores de respuesta
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Token expirado o invÃ¡lido
      localStorage.removeItem('token');
      localStorage.removeItem('user');
      window.location.href = '/login';
    }
    
    // Mejorar mensajes de error
    const message = error.response?.data?.message || error.message || 'Error en la peticiÃ³n';
    error.message = message;
    
    return Promise.reject(error);
  }
);

export default api;
EOF

echo -e "${BLUE}âœ“ Creado: frontend/src/services/api.js${NC}"

# authService.js
cat > frontend/src/services/authService.js << 'EOF'
// Servicio de AutenticaciÃ³n

import api from './api';

const authService = {
  /**
   * Iniciar sesiÃ³n
   */
  async login(username, password) {
    const response = await api.post('/auth/login', { username, password });
    
    if (response.data.token) {
      localStorage.setItem('token', response.data.token);
      localStorage.setItem('user', JSON.stringify(response.data.user));
    }
    
    return response.data;
  },

  /**
   * Cerrar sesiÃ³n
   */
  logout() {
    localStorage.removeItem('token');
    localStorage.removeItem('user');
  },

  /**
   * Obtener usuario actual
   */
  getCurrentUser() {
    const userStr = localStorage.getItem('user');
    return userStr ? JSON.parse(userStr) : null;
  },

  /**
   * Verificar si estÃ¡ autenticado
   */
  isAuthenticated() {
    return !!localStorage.getItem('token');
  },

  /**
   * Obtener token
   */
  getToken() {
    return localStorage.getItem('token');
  },

  /**
   * Verificar si el usuario tiene un rol especÃ­fico
   */
  hasRole(role) {
    const user = this.getCurrentUser();
    return user?.rol === role;
  },

  /**
   * Verificar si el usuario es admin
   */
  isAdmin() {
    return this.hasRole('admin');
  }
};

export default authService;
EOF

echo -e "${BLUE}âœ“ Creado: frontend/src/services/authService.js${NC}"

# userService.js
cat > frontend/src/services/userService.js << 'EOF'
// Servicio de Usuarios

import api from './api';

const userService = {
  /**
   * Obtener todos los usuarios
   */
  async getAll(filtros = {}) {
    const response = await api.get('/users', { params: filtros });
    return response.data;
  },

  /**
   * Obtener usuario por ID
   */
  async getById(id) {
    const response = await api.get(`/users/${id}`);
    return response.data;
  },

  /**
   * Crear nuevo usuario
   */
  async create(userData) {
    const response = await api.post('/users', userData);
    return response.data;
  },

  /**
   * Actualizar usuario
   */
  async update(id, userData) {
    const response = await api.put(`/users/${id}`, userData);
    return response.data;
  },

  /**
   * Eliminar usuario
   */
  async delete(id) {
    const response = await api.delete(`/users/${id}`);
    return response.data;
  },

  /**
   * Buscar usuarios
   */
  async search(query) {
    const response = await api.get('/users', { params: { search: query } });
    return response.data;
  }
};

export default userService;
EOF

echo -e "${BLUE}âœ“ Creado: frontend/src/services/userService.js${NC}"

# medicionService.js
cat > frontend/src/services/medicionService.js << 'EOF'
// Servicio de Mediciones

import api from './api';

const medicionService = {
  /**
   * Obtener todas las mediciones
   */
  async getAll(filtros = {}) {
    const response = await api.get('/mediciones', { params: filtros });
    return response.data;
  },

  /**
   * Obtener mediciÃ³n por ID
   */
  async getById(id) {
    const response = await api.get(`/mediciones/${id}`);
    return response.data;
  },

  /**
   * Crear nueva mediciÃ³n
   */
  async create(medicionData) {
    const response = await api.post('/mediciones', medicionData);
    return response.data;
  },

  /**
   * Actualizar mediciÃ³n
   */
  async update(id, medicionData) {
    const response = await api.put(`/mediciones/${id}`, medicionData);
    return response.data;
  },

  /**
   * Eliminar mediciÃ³n
   */
  async delete(id) {
    const response = await api.delete(`/mediciones/${id}`);
    return response.data;
  },

  /**
   * Obtener Ãºltima mediciÃ³n de un medidor
   */
  async getUltimaPorMedidor(medidorId) {
    const response = await api.get(`/mediciones/ultima/${medidorId}`);
    return response.data;
  }
};

export default medicionService;
EOF

echo -e "${BLUE}âœ“ Creado: frontend/src/services/medicionService.js${NC}"

# facturaService.js
cat > frontend/src/services/facturaService.js << 'EOF'
// Servicio de Facturas

import api from './api';

const facturaService = {
  /**
   * Obtener todas las facturas
   */
  async getAll(filtros = {}) {
    const response = await api.get('/facturas', { params: filtros });
    return response.data;
  },

  /**
   * Obtener factura por ID
   */
  async getById(id) {
    const response = await api.get(`/facturas/${id}`);
    return response.data;
  },

  /**
   * Generar nueva factura
   */
  async create(facturaData) {
    const response = await api.post('/facturas', facturaData);
    return response.data;
  },

  /**
   * Actualizar factura
   */
  async update(id, facturaData) {
    const response = await api.put(`/facturas/${id}`, facturaData);
    return response.data;
  },

  /**
   * Eliminar factura
   */
  async delete(id) {
    const response = await api.delete(`/facturas/${id}`);
    return response.data;
  },

  /**
   * Registrar pago de factura
   */
  async registrarPago(id, pagoData) {
    const response = await api.post(`/facturas/${id}/pagar`, pagoData);
    return response.data;
  },

  /**
   * Obtener facturas vencidas
   */
  async getVencidas() {
    const response = await api.get('/facturas/vencidas');
    return response.data;
  },

  /**
   * Obtener estadÃ­sticas de facturas
   */
  async getEstadisticas(periodo = null) {
    const response = await api.get('/facturas/estadisticas', { 
      params: { periodo } 
    });
    return response.data;
  }
};

export default facturaService;
EOF

echo -e "${BLUE}âœ“ Creado: frontend/src/services/facturaService.js${NC}"

# AuthContext.jsx
cat > frontend/src/context/AuthContext.jsx << 'EOF'
// Context de AutenticaciÃ³n

import { createContext, useContext, useState, useEffect } from 'react';
import authService from '../services/authService';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Verificar si hay un usuario en localStorage al cargar
    const currentUser = authService.getCurrentUser();
    if (currentUser) {
      setUser(currentUser);
    }
    setLoading(false);
  }, []);

  const login = async (username, password) => {
    const data = await authService.login(username, password);
    setUser(data.user);
    return data;
  };

  const logout = () => {
    authService.logout();
    setUser(null);
  };

  const value = {
    user,
    login,
    logout,
    isAuthenticated: !!user,
    isAdmin: user?.rol === 'admin',
    loading
  };

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth debe usarse dentro de AuthProvider');
  }
  return context;
};
EOF

echo -e "${BLUE}âœ“ Creado: frontend/src/context/AuthContext.jsx${NC}"

# useApi hook
cat > frontend/src/hooks/useApi.js << 'EOF'
// Custom hook para peticiones API

import { useState, useCallback } from 'react';

export const useApi = (apiFunc) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const execute = useCallback(async (...params) => {
    try {
      setLoading(true);
      setError(null);
      const result = await apiFunc(...params);
      setData(result);
      return result;
    } catch (err) {
      setError(err.message || 'Error en la peticiÃ³n');
      throw err;
    } finally {
      setLoading(false);
    }
  }, [apiFunc]);

  const reset = () => {
    setData(null);
    setError(null);
    setLoading(false);
  };

  return { data, loading, error, execute, reset };
};
EOF

echo -e "${BLUE}âœ“ Creado: frontend/src/hooks/useApi.js${NC}"

# Script de datos de prueba
cat > backend/config/seed-data.sql << 'EOF'
-- Datos de prueba para Sistema de Cobro de Agua Potable

-- Insertar usuario administrador del sistema
-- Password: admin123 (debe ser hasheado con bcrypt en producciÃ³n)
INSERT INTO usuarios_sistema (username, password_hash, nombre_completo, rol, email, activo) 
VALUES (
  'admin',
  '$2a$10$rZ5z0XqHJC8Y5v8Y5v8Y5ujKvB.C0QnM8Y5v8Y5v8Y5v8Y5v8Y5v8Y',
  'Administrador Sistema',
  'admin',
  'admin@agua.com',
  true
) ON CONFLICT (username) DO NOTHING;

-- Insertar tarifa por defecto para usuarios domÃ©sticos
INSERT INTO tarifas (tipo_usuario, consumo_minimo, consumo_maximo, tarifa_base, tarifa_por_m3, fecha_inicio, activa)
VALUES 
  ('domestico', 0, 10, 50.00, 5.00, CURRENT_DATE, true),
  ('comercial', 0, 20, 100.00, 8.00, CURRENT_DATE, true),
  ('industrial', 0, 50, 200.00, 12.00, CURRENT_DATE, true)
ON CONFLICT DO NOTHING;

-- Usuarios de ejemplo
INSERT INTO usuarios (numero_usuario, nombres, apellidos, direccion, telefono, email, tipo_usuario, estado)
VALUES 
  ('USR-001', 'Juan', 'PÃ©rez GarcÃ­a', 'Calle Principal #123', '4421234567', 'juan.perez@email.com', 'domestico', 'activo'),
  ('USR-002', 'MarÃ­a', 'GonzÃ¡lez LÃ³pez', 'Av. Central #456', '4427654321', 'maria.gonzalez@email.com', 'domestico', 'activo'),
  ('USR-003', 'Comercial La Esquina', 'S.A. de C.V.', 'Plaza Comercial #789', '4429876543', 'contacto@laesquina.com', 'comercial', 'activo')
ON CONFLICT (numero_usuario) DO NOTHING;

-- Medidores de ejemplo
INSERT INTO medidores (numero_medidor, usuario_id, marca, modelo, fecha_instalacion, lectura_inicial, estado)
SELECT 
  'MED-001', 
  id, 
  'Itron', 
  'Aquadis+', 
  '2024-01-01', 
  0, 
  'activo'
FROM usuarios WHERE numero_usuario = 'USR-001'
ON CONFLICT (numero_medidor) DO NOTHING;

INSERT INTO medidores (numero_medidor, usuario_id, marca, modelo, fecha_instalacion, lectura_inicial, estado)
SELECT 
  'MED-002', 
  id, 
  'Sensus', 
  'iPERL', 
  '2024-01-01', 
  0, 
  'activo'
FROM usuarios WHERE numero_usuario = 'USR-002'
ON CONFLICT (numero_medidor) DO NOTHING;

INSERT INTO medidores (numero_medidor, usuario_id, marca, modelo, fecha_instalacion, lectura_inicial, estado)
SELECT 
  'MED-003', 
  id, 
  'Elster', 
  'V100', 
  '2024-01-01', 
  0, 
  'activo'
FROM usuarios WHERE numero_usuario = 'USR-003'
ON CONFLICT (numero_medidor) DO NOTHING;

SELECT 'Datos de prueba insertados correctamente' as mensaje;
EOF

echo -e "${BLUE}âœ“ Creado: backend/config/seed-data.sql${NC}"

# ============================================
# RESUMEN Y SIGUIENTES PASOS
# ============================================

echo ""
echo -e "${GREEN}==============================================
   * Crear un nuevo usuario del servicio
   */
  static async crear(datos) {
    const { 
      numero_usuario, nombres, apellidos, direccion, 
      telefono, email, tipo_usuario 
    } = datos;
    
    const query = `
      INSERT INTO usuarios 
      (numero_usuario, nombres, apellidos, direccion, telefono, email, tipo_usuario, estado)
      VALUES ($1, $2, $3, $4, $5, $6, $7, 'activo')
      RETURNING *
    `;
    
    const values = [numero_usuario, nombres, apellidos, direccion, telefono, email, tipo_usuario];
    const result = await db.query(query, values);
    return result.rows[0];
  }

  /**
   * Obtener todos los usuarios
   */
  static async obtenerTodos(filtros = {}) {
    let query = 'SELECT * FROM usuarios WHERE 1=1';
    const values = [];
    let paramCount = 1;

    if (filtros.tipo_usuario) {
      query += ` AND tipo_usuario = $${paramCount}`;
      values.push(filtros.tipo_usuario);
      paramCount++;
    }

    if (filtros.estado) {
      query += ` AND estado = $${paramCount}`;
      values.push(filtros.estado);
      paramCount++;
    }

    if (filtros.search) {
      query += ` AND (nombres ILIKE $${paramCount} OR apellidos ILIKE $${paramCount} OR numero_usuario ILIKE $${paramCount})`;
      values.push(`%${filtros.search}%`);
      paramCount++;
    }

    query += ' ORDER BY apellidos, nombres';

    const result = await db.query(query, values);
    return result.rows;
  }

  /**
   * Obtener usuario por ID
   */
  static async obtenerPorId(id) {
    const query = 'SELECT * FROM usuarios WHERE id = $1';
    const result = await db.query(query, [id]);
    return result.rows[0];
  }

  /**
   * Obtener usuario por nÃºmero de usuario
   */
  static async obtenerPorNumero(numero_usuario) {
    const query = 'SELECT * FROM usuarios WHERE numero_usuario = $1';
    const result = await db.query(query, [numero_usuario]);
    return result.rows[0];
  }

  /**
   * Actualizar usuario
   */
  static async actualizar(id, datos) {
    const { nombres, apellidos, direccion, telefono, email, tipo_usuario, estado } = datos;
    
    const query = `
      UPDATE usuarios 
      SET nombres = $1, apellidos = $2, direccion = $3, telefono = $4, 
          email = $5, tipo_usuario = $6, estado = $7
      WHERE id = $8
      RETURNING *
    `;
    
    const values = [nombres, apellidos, direccion, telefono, email, tipo_usuario, estado, id];
    const result = await db.query(query, values);
    return result.rows[0];
  }

  /**
   * Eliminar usuario
   */
  static async eliminar(id) {
    const query = 'DELETE FROM usuarios WHERE id = $1';
    await db.query(query, [id]);
  }

  /**
   * Contar usuarios
   */
  static async contar() {
    const query = 'SELECT COUNT(*) as total FROM usuarios';
    const result = await db.query(query);
    return parseInt(result.rows[0].total);
  }
}

module.exports = Usuario;
EOF

echo -e "${BLUE}âœ“ Actualizado: backend/models/Usuario.js${NC}"

# Modelo Medicion.js para PostgreSQL
cat > backend/models/Medicion.js << 'EOF'
// Modelo de MediciÃ³n (PostgreSQL)

const db = require('../config/database');

class Medicion {
  
  /**
   * Crear una nueva mediciÃ³n
   */
  static async crear(datos) {
    const { 
      medidor_id, lectura_anterior, lectura_actual, 
      periodo, fecha_lectura, observaciones, leido_por 
    } = datos;
    
    const query = `
      INSERT INTO mediciones 
      (medidor_id, lectura_anterior, lectura_actual, periodo, fecha_lectura, observaciones, leido_por)
      VALUES ($1, $2, $3, $4, $5, $6, $7)
      RETURNING *
    `;
    
    const values = [medidor_id, lectura_anterior, lectura_actual, periodo, fecha_lectura, observaciones, leido_por];
    const result = await db.query(query, values);
    return result.rows[0];
  }

  /**
   * Obtener todas las mediciones con informaciÃ³n del medidor y usuario
   */
  static async obtenerTodas(filtros = {}) {
    let query = `
      SELECT m.*, med.numero_medidor, u.nombres, u.apellidos, u.numero_usuario
      FROM mediciones m
      JOIN medidores med ON m.medidor_id = med.id
      JOIN usuarios u ON med.usuario_id = u.id
      WHERE 1=1
    `;
    
    const values = [];
    let paramCount = 1;

    if (filtros.medidor_id) {
      query += ` AND m.medidor_id = $${paramCount}`;
      values.push(filtros.medidor_id);
      paramCount++;
    }

    if (filtros.periodo) {
      query += ` AND m.periodo = $${paramCount}`;
      values.push(filtros.periodo);
      paramCount++;
    }

    if (filtros.fecha_desde) {
      query += ` AND m.fecha_lectura >= $${paramCount}`;
      values.push(filtros.fecha_desde);
      paramCount++;
    }

    if (filtros.fecha_hasta) {
      query += ` AND m.fecha_lectura <= $${paramCount}`;
      values.push(filtros.fecha_hasta);
      paramCount++;
    }

    query += ' ORDER BY m.fecha_lectura DESC';

    const result = await db.query(query, values);
    return result.rows;
  }

  /**
   * Obtener mediciÃ³n por ID
   */
  static async obtenerPorId(id) {
    const query = `
      SELECT m.*, med.numero_medidor, u.nombres, u.apellidos
      FROM mediciones m
      JOIN medidores med ON m.medidor_id = med.id
      JOIN usuarios u ON med.usuario_id = u.id
      WHERE m.id = $1
    `;
    
    const result = await db.query(query, [id]);
    return result.rows[0];
  }

  /**
   * Obtener Ãºltima mediciÃ³n de un medidor
   */
  static async obtenerUltimaPorMedidor(medidor_id) {
    const query = `
      SELECT * FROM mediciones
      WHERE medidor_id = $1
      ORDER BY fecha_lectura DESC
      LIMIT 1
    `;
    
    const result = await db.query(query, [medidor_id]);
    return result.rows[0];
  }

  /**
   * Verificar si existe mediciÃ³n para un periodo y medidor
   */
  static async existeMedicion(medidor_id, periodo) {
    const query = `
      SELECT COUNT(*) as count
      FROM mediciones
      WHERE medidor_id = $1 AND periodo = $2
    `;
    
    const result = await db.query(query, [medidor_id, periodo]);
    return parseInt(result.rows[0].count) > 0;
  }

  /**
   * Actualizar mediciÃ³n
   */
  static async actualizar(id, datos) {
    const { lectura_actual, fecha_lectura, observaciones } = datos;
    
    const query = `
      UPDATE mediciones 
      SET lectura_actual = $1, fecha_lectura = $2, observaciones = $3
      WHERE id = $4
      RETURNING *
    `;
    
    const values = [lectura_actual, fecha_lectura, observaciones, id];
    const result = await db.query(query, values);
    return result.rows[0];
  }

  /**
   * Eliminar mediciÃ³n
   */
  static async eliminar(id) {
    const query = 'DELETE FROM mediciones WHERE id = $1';
    await db.query(query, [id]);
  }
}

module.exports = Medicion;
EOF

echo -e "${BLUE}âœ“ Creado: backend/models/Medicion.js${NC}"

# Modelo Factura.js para PostgreSQL
cat > backend/models/Factura.js << 'EOF'
// Modelo de Factura (PostgreSQL)

const db = require('../config/database');

class Factura {
  
  /**
   * Crear una nueva factura
   */
  static async crear(datos) {
    const {
      usuario_id, medicion_id, numero_factura, periodo, consumo,
      monto_consumo, monto_fijo, otros_cargos, descuentos, total,
      fecha_emision, fecha_vencimiento
    } = datos;
    
    const query = `
      INSERT INTO facturas 
      (usuario_id, medicion_id, numero_factura, periodo, consumo, 
       monto_consumo, monto_fijo, otros_cargos, descuentos, total,
       estado, fecha_emision, fecha_vencimiento)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, 'pendiente', $11, $12)
      RETURNING *
    `;
    
    const values = [
      usuario_id, medicion_id, numero_factura, periodo, consumo,
      monto_consumo, monto_fijo, otros_cargos, descuentos, total,
      fecha_emision, fecha_vencimiento
    ];
    
    const result = await db.query(query, values);
    return result.rows[0];
  }

  /**
   * Obtener todas las facturas
   */
  static async obtenerTodas(filtros = {}) {
    let query = `
      SELECT f.*, u.numero_usuario, u.nombres, u.apellidos, u.direccion
      FROM facturas f
      JOIN usuarios u ON f.usuario_id = u.id
      WHERE 1=1
    `;
    
    const values = [];
    let paramCount = 1;

    if (filtros.usuario_id) {
      query += ` AND f.usuario_id = $${paramCount}`;
      values.push(filtros.usuario_id);
      paramCount++;
    }

    if (filtros.estado) {
      query += ` AND f.estado = $${paramCount}`;
      values.push(filtros.estado);
      paramCount++;
    }

    if (filtros.periodo) {
      query += ` AND f.periodo = $${paramCount}`;
      values.push(filtros.periodo);
      paramCount++;
    }

    query += ' ORDER BY f.fecha_emision DESC';

    const result = await db.query(query, values);
    return result.rows;
  }

  /**
   * Obtener factura por ID
   */
  static async obtenerPorId(id) {
    const query = `
      SELECT f.*, u.numero_usuario, u.nombres, u.apellidos, u.direccion, u.telefono
      FROM facturas f
      JOIN usuarios u ON f.usuario_id = u.id
      WHERE f.id = $1
    `;
    
    const result = await db.query(query, [id]);
    return result.rows[0];
  }

  /**
   * Actualizar estado de factura
   */
  static async actualizarEstado(id, estado) {
    const query = 'UPDATE facturas SET estado = $1 WHERE id = $2 RETURNING *';
    const result = await db.query(query, [estado, id]);
    return result.rows[0];
  }

  /**
   * Obtener facturas vencidas
   */
  static async obtenerVencidas() {
    const query = `
      SELECT f.*, u.numero_usuario, u.nombres, u.apellidos, u.telefono
      FROM facturas f
      JOIN usuarios u ON f.usuario_id = u.id
      WHERE f.estado = 'pendiente' 
      AND f.fecha_vencimiento < CURRENT_DATE
      ORDER BY f.fecha_vencimiento
    `;
    
    const result = await db.query(query);
    return result.rows;
  }

  /**
   * Obtener estadÃ­sticas de facturas
   */
  static async obtenerEstadisticas(periodo = null) {
    let query = `
      SELECT 
        COUNT(*) as total,
        SUM(CASE WHEN estado = 'pendiente' THEN 1 ELSE 0 END) as pendientes,
        SUM(CASE WHEN estado = 'pagada' THEN 1 ELSE 0 END) as pagadas,
        SUM(CASE WHEN estado = 'vencida' THEN 1 ELSE 0 END) as vencidas,
        SUM(total) as monto_total,
        SUM(CASE WHEN estado = 'pagada' THEN total ELSE 0 END) as monto_cobrado,
        SUM(CASE WHEN estado = 'pendiente' OR estado = 'vencida' THEN total ELSE 0 END) as monto_pendiente
      FROM facturas
    `;

    const values = [];
    if (periodo) {
      query += ' WHERE periodo = $1';
      values.push(periodo);
    }

    const result = await db.query(query, values);
    return result.rows[0];
  }

  /**
